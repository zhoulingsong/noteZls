## 四种隔离级别

* **Read uncommitted 读未提交**

  一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据读。 因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读。

* **Read committed 读提交** 

  未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。

* **Repeatable read 重复读**

  读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。

* **Serializable 序列化**

  该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。







- 读未提交（read uncommited）：事务可以读到其他事务已修改未提交的数据。这种隔离级别下，如果语句在时间顺序上执行的是 1、3，那么1的结果就是state='0'，如果顺序是3、1，那么1的结果就是state='1'；如果读到了事务T2未提交的数据，而T2又因为执行错误回滚，事务T1读到的数据就是脏数据，这种情况称为脏读。
- 读已提交（read commited）：事务读到的都是其他事务已提交过的数据。这种隔离级别下，如果语句1执行时，T2未提交，则语句1读到state='0'，如果T2提交则读到state='1'，不会读到未提交的数据了。但是，新的问题来了，如果T1中有又增加了语句5，语句5跟语句1一样，那么1和5的结果可能不一样吗？答案是有这种概率。如果 执行时间顺序是这样的，1 ，事务T2提交，5，这样1和5读到的数据就不一致了，同一个事务中同一条语句读到了不同的数据？这种情况就称之为**不可重复读**。有办法解决吗？有！就是语句1读取的时候，把读到的数据加锁，不允许再修改，直至事务提交或回滚再释放锁。
- 可重复读（read repeatable）：事务内部对数据的读取前后是一致的。这种隔离级别解决了不可重复读的情况，实现方案前面也提到了，就是加锁。但是还有一种情况，你是锁不住的，那就是T2中有insert怎么办？语句1的where 条件去掉，这样语句1 就是查询所有数据了，这时候把读出来的数据都锁住，别的事务不允许操作，但这时候T2给A表新增了一条数据，并在事务T1提交前提交的。事务T1以为处理了所有的A表数据，但发现多出来一条其他数据。这种情况称为**幻读**
- 串行读（ Serializable）：完全串行化读，使用表级锁，读和写都会阻塞。这种情况下，数据库的并非能力受限、性能不高，但数据的正确性有保障。