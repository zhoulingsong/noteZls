## Java 垃圾回收机制

* ### GC 分类

  ~~~
  Minor GC ：工作在新生代；
  Major GC ：即 Full GC，工作在老年代和永久代；
  ~~~

* ### 回收区域

  ~~~
  不需要回收的区域：
  	程序计数器、JVM栈、本地方法栈。它们的生命周期是和线程同步的，随着线程的销毁，
  	它们占用的内存会自动释放；
  需要回收的区域：方法区(堆中的永久代)和堆(新生代、老年代)；
  	新生代：Eden、form survicor space、to survivor space
  ~~~

* ###  回收对象-可达性分析算法

  ~~~
  从GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被判定为是可回收的对象。
  
  可作为GC Roots的对象包括下面几种： 
  a) 虚拟机栈中引用的对象（栈帧中的本地变量表）； 
  b) 方法区中类静态属性引用的对象； 
  c) 方法区中常量引用的对象； 
  d) 本地方法栈中JNI（Native方法）引用的对象。
  ~~~

* ###  死亡前的挣扎

  ~~~
  通过可达性分析，那些不可达的对象并不是立即被销毁，他们还有被拯救的机会。 
  回收一个不可达对象，要经历两次标记过程。首先是第一次标记，并判断对象是否覆写了 finalize 方法，如果没有覆写，则直接进行第二次标记并被回收。如果对象在 finalize 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。强烈不推荐使用 finalize 方法。
  ~~~

* ### 方法区对象回收

  ~~~ 
  方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件： 
  ① 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例； 
  ② 加载该类的 ClassLoader 已经被回收； 
  ③ 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
  ~~~

  

## 二、回收算法

* ### 标记-清除算法

  ~~~
  从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，此算法一般没有虚拟机采用。 
  优点1：解决了循环引用的问题 
  优点2：与复制算法相比，不需要对象移动，效率较高，而且还不需要额外的空间 
  不足1：每个活跃的对象都要进行扫描，而且要扫描两次，效率较低，收集暂停的时间比较长。 
  不足2：产生不连续的内存碎片 
  ~~~

* ### 复制算法

  ~~~
  将内存分成两块容量大小相等的区域，每次只使用其中一块，当这一块内存用完了，就将所有存活对象复制到另一块内存空间，然后清除前一块内存空间。这样一来就不容易出现内存碎片的问题。 
  1、复制的代价较高，所以适合新生代，因为新生代的对象存活率较低，需要复制的对象较少； 
  2、需要双倍的内存空间，而且总是有一块内存空闲，浪费空间 
  ~~~

* ### 标记-整理算法

  ~~~
  在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。 不会产生内存碎片，但是移动对象成本高。
  ~~~



###  分代收集

~~~
分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation）,在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。 

内存被分为下面三个区域： 
① 新生代：Enden、form survicor space、to survivor space。 
② 老年代 
③ 永久代：方法区 

新生代的回收算法 
包含有Enden、form survicor space、to survivor space三个区，绝大多数最新被创建的对象会被分配到这里，大部分对象在创建之后会变得很快不可达。 
① 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 
② 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 
③ 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 
④ 新生代发生的GC也叫做Minor GC，Minor GC发生频率比较高(不一定等Eden区满了才触发)。 

老年代的回收算法 
① 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 
② 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 

永久代的回收算法 
用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区。 

五、常见的垃圾收集器 
 
Serial收集器（复制算法) 
新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。 
Serial Old收集器(标记-整理算法) 
老年代单线程收集器，Serial收集器的老年代版本。 
ParNew收集器(停止-复制算法)　 
新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。 
Parallel Scavenge收集器(停止-复制算法)　 
并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。 
Parallel Old收集器(停止-复制算法) 
Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。 
CMS(Concurrent Mark Sweep)收集器（标记-清理算法） 
高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。 
~~~



## 三、GC 触发条件

* ### Minor GC 

  ~~~ 
  当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。
  ~~~

* ### Major GC

  ~~~
  对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC： 
  a) 年老代（Tenured）被写满； 
  b) 持久代（Perm）被写满； 
  c) System.gc()被显示调用； 
  d) 上一次GC之后Heap的各域分配策略动态变化；
  ~~~



**jvm查看gc命令** 
jstat -gc 12538 5000 ：每 5 秒显示进程号为 12538 的 java 进成的 GC 情况；
