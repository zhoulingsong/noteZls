1. **原子性**：**synchronized**、**Lock**

2. **可见性**：**volatile**、**synchronized**、**Lock**

   ~~~
   通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中
   ~~~

3. **有序性**：**volatile**、**synchronized**、**Lock**、**final**

   ~~~
   1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
   2） 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。
   ~~~

   





## volatile

~~~
保证可见性和一定的有序性。　　
　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
　　2）禁止进行指令重排序。

volatile关键字禁止指令重排序有两层意思：
　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
~~~



## synchronized

~~~
synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现形式：对于普通同步方法，锁是当前实例对象；对于静态同步方法，锁是当前类的Class对象；对于同步代码块，锁是synchronized括号里配置的对象。当一个线程试图访问同步代码块/同步方法时，必须先得到锁，退出或者抛出异常时必须释放锁。

 synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽存储对象头，非数组类型使用2字宽存储对象头。1宽等于4字节。
~~~

* 锁状态

  **无锁、偏向锁、轻量级锁、重量级锁**。
  锁可以升级，但是不可以降级，目的是为了提高获得锁和释放锁的效率



## 线程运行状态

![image-20190731143225374](/Users/lx/zls/Projects/gitZls/git/noteZls/b后台/java高级/并发编程/并发编程的艺术/image-20190731143225374.png)