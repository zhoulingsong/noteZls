## 1. 热点 (hot) key

* **场景**

  并发达到10W-100W。

* **解决方案**

  1. JVM 本地缓存。

     ~~~
     带来两个问题：
     1、寻找 hot key 进行缓存，本地缓存是否会过大，影响应用程序本身所需的缓存开销。
     2、数据有效期的一致性。
     ~~~

  2. 备份到多个 key。

     ~~~
     利用分片算法的特性，对key进行打散处理。
     给 hot key 加前缀/后缀，把一个 key 变成 redis 实例个数 N 的倍数 M 即 N * M 个 key。经过分片分布到不同的实例上，将访问量均摊到所有实例。
     
     通过一个大于等于 1 小于 M * N 的随机数，得到一个 tmp key，程序会优先访问tmp key，在得不到数据的情况下，再访问原来的 hot key，并将 hot key的内容写回 tmp key。值得注意的是，tmp key的过期时间是 hot key 的过期时间加上一个较小的随机正整数，保证在 hot key 过期时，所有 tmp key 不会同时过期而造成缓存雪崩。这是一种通过坡度过期的方式来避免雪崩的思路，同时也可以利用原子锁来写入数据就更加的完美，减小db的压力。
     注意：Twemproxy 分片算法越靠前的字符权重越大，考后的字符权重则越小。所以 key 不宜太长。
     ~~~

     

## 2. big key

* **场景**

  存储的数据量远大于其他 key。

* **解决方案**

  key 拆分

