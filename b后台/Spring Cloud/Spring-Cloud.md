## 组件

- Spring Cloud Netflix：核心组件，包括以下几个组件：
  - Eureka：服务治理组件，包含服务注册与发现
  - Hystrix：容错管理组件，实现了熔断器
  - Ribbon：客户端负载均衡的服务调用组件
  - Feign：基于Ribbon和Hystrix的声明式服务调用组件
  - Zuul：网关组件，提供智能路由、访问过滤等功能
  - Archaius：外部化配置组件
- Spring Cloud Config：配置管理工具，实现应用配置的外部化存储，支持客户端配置信息刷新、加密/解密配置内容等。
- Spring Cloud Bus：事件、消息总线，用于传播集群中的状态变化或事件，以及触发后续的处理
- Spring Cloud Security：基于spring security的安全工具包，为我们的应用程序添加安全控制
- Spring Cloud Consul : 封装了Consul操作，Consul是一个服务发现与配置工具（与Eureka作用类似），与Docker容器可以无缝集成







## Dubbo 和 Spring Cloud 对比

|              |       Dubbo       |                       Spring Cloud                        |
| ------------ | :---------------: | :-------------------------------------------------------: |
| 服务注册中心 | Zookeeper、redis  |                Spring Cloud Netflix Eureka                |
| 通讯方式     |        RPC        |                         REST API                          |
| 服务监控     |   Dubbo-monitor   |                     Spring Boot Admin                     |
| 断路器       |      不完善       |               Spring Cloud NetFlix Hystrix                |
| 服务网关     |        无         |             Spring Cloud Gateway/NetFlix Zuul             |
| 服务跟踪     |        无         |                    Spring Cloud Sleuth                    |
| 服务总线     |        无         |                     Spring Cloud Bus                      |
| 分布式配置   |        无         |                    Spring Cloud Config                    |
| 批量任务     |        无         |                     Spring Cloud Task                     |
| 数据流       |        无         |                    Spring Cloud Stream                    |
|              |                   |                                                           |
| 负载均衡     | 支持服务端+客户端 | Spring Cloud Netflix Ribbon(客户端)Eureka(服务的负载均衡) |



## Eureka 服务的注册与发现

~~~
CAP 理论的基于 AP 实现，zookeper 是基于 CP 实现。认为可用性比一致性更重要。
包含两个组件：Eureka Server（注册中心）和Eureka Client（服务提供者和消费者）。
~~~

#### 调用流程

1. 服务提供者在启动时，向注册中心注册自己提供的服务。
2. 服务消费者在启动时，向注册中心订阅自己所需的服务。
3. 注册中心返回服务提供者地址给消费者。
4. 服务消费者从提供者地址中调用消费者。



**Eureka Server**：提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，包括主机与端口号、服务版本号、通讯协议等。这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。
 Eureka服务端支持集群模式部署，首尾相连形成一个闭环即可，集群中的的不同服务注册中心通过异步模式互相复制各自的状态，这也意味着在给定的时间点每个实例关于所有服务的状态可能存在不一致的现象。

**eureka客户端**，主要处理服务的注册和发现。客户端服务通过注册和参数配置的方式，嵌入在客户端应用程序的代码中。在应用程序启动时，Eureka客户端向服务注册中心注册自身提供的服务，并周期性的发送心跳来更新它的服务租约。同时，他也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期行的刷新服务状态。

**服务调用**
 服务消费者在获取服务清单后，通过服务名可以获取具体提供服务的实例名和该实例的元数据信息。因为有这些服务实例的详细信息，所以客户端可以根据自己的需要决定具体调用哪个实例，在Ribbon中会默认采用轮询的方式进行调用，从而实现客户端的负载均衡。



**高可用方案：**通过相互注册来实现。



1.基本原理

        服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费者调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存到本地，下次再调用的时候，直接从本地缓存中读取，完成一次调用。
    
       当服务注册中心Eureka Server监测到服务器提供者因为宕机，网络原因等不可用时，则再服务注册中心将服务置为DOWN状态，并把当前服务提供者状态向订阅者发布，订阅过的服务消费者更新本地缓存。
    
      服务提供者在启动后，周期性(默认30秒)向Eureka Server发送心跳，以证明当前服务时可用状态。Eureka Server在一定时间(默认90秒)未收到客户端的心跳，则认为服务宕机，注销该实例。

2.Eureka的自我保护机制

        在默认的配置中，Eureka Server在默认90秒没有得到客户端的心跳，则注销该实例，但是往往因为微服务跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，但是因为网络分区故障，Eureka Server注销服务实例，则会让大部分微服务不可用，这很危险，因为微服务本身是没有问题的。

为了解决这一问题，Eureka有自我保护机制，Eureka Server通过配置如下参数，可启动自我保护机制

eureka.server.enable-self-preservation=true
        它的原理是，当Eureka Server节点在短时间内丢失过多的客户端时(可能发生了网络故障)，那么这个节点将进入自我保护模式，不嫩恶搞注销任何微服务，当网络故障恢复后，该节点会自动退出自我保护模式。

二、了解Zookeeper

    Zookeeper是一个分布式的应用程序协调服务，是集群的管理者，监视着集群中各个节点的状态，根据节点替吉奥的反馈进行下一步合理操作，最终，将简单易用的接和性能高效，功能稳定的系统提供给用户。

三、以上两个都是服务注册中心角色，Eureka比Zookeeper好在哪里？

| Erueka                     | Zookeeper                            |
| -------------------------- | ------------------------------------ |
| 保证高可用（AP）           | 保证一致性（CP）                     |
| 缓存，不持久化             | 持久化                               |
| 增量更新注册信息           | watch 事件监控变化                   |
| 提供客户端缓存             | 无客户端缓存                         |
| 适合作为服务注册、发现中心 | 适合分布式协调服务                   |
| 对等集群                   | master/follower 选举期间不能提供服务 |
|                            |                                      |

著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)、P（分区容错性）。由于分区容错性是在分布式系统中必须要保证的，因此我们需要在A和C之间进行权衡。Zookeeper保证的是CP，而Eureka保证的是AP.

1.Zookeeper保证CP

   当注册中心查询服务列表时，我们可以容忍注册中心返回的时几分钟以前的注册信息，但是不能接受服务直接DOWN掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余的节点要重新进行leader选举。问题在于，选举的时间太长，30-120s,并且选举期间整个zk集群式不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，由于网络问题使得zk集群失去master节点式较大概率发生的事情，虽然服务能够最终恢复，但是漫长的选举时间导致注册长期不可用是不能接受的。

2.Eureka保证AP

   Eureka正好解决了zk的这一问题，因此在设计时候就优先保证高可用。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka Server注册时如果发现连接失败，则会自动切换到其他节点，只要有一台Eureka Server在，就能保证注册服务可用，只不过查到的信息可能不是最新的。除此之外，Eureka还有一种自我保护的机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现网络故障，此时会出现以下几种情况:

   1.Eureka不再从注册列表中移除因为长时间没接收到心跳而应该过期的服务。

   2.Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步在其他节点上

   3.当网络稳定时，当前实例新的注册信息会被同步到其他节点上。

因此，Eureka可以很好的应对因网络故障倒是部分节点失去联系的情况，而不像zk那样整个注册服务瘫痪。

四、总结

Eureka作为单纯的服务注册中心来说要比zookeeper更加“专业”。因为注册服务更重要的时可用性，我们可以接受短时间达不到一致性的状况。



## Hystrix 熔断器

Hystrix的容错主要是通过添加容许延迟和容错方法，帮助控制这些分布式服务之间的交互。 还通过隔离服务之间的访问点，阻止它们之间的级联故障以及提供回退选项来实现这一点，从而提高系统的整体弹性。

**容错方案：**

- 资源隔离

  ~~~
  资源隔离主要指对线程的隔离。提供了两种线程隔离方式：线程池和信号量。
  ~~~

- 熔断

- 降级