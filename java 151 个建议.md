# 《JAVA 151 个建议》

## 第一章

## 第二章 基本类型

### 21. 用偶判断，不用奇判断
	
	原因： 1 % 2 = 1； -1 % 2 = -1; 单 2 % 2 = 0； -2 % 2 = 0；
	结论： 负奇数 % 2 等于 -1， 正奇数 % 2 等于 1，正负偶数 % 2 都等于 0；
 
### 22. 精确小数用 BigDecimal

### 23. 自动类型转换时主动转换防止溢出

	long num = 1L * num1 * num2; (推荐)
	long num = (long)num1 * (long)num2 	(不推荐)
	第一个参数就主动声明类型转换成 long，而不是使用强制类型转换




## 第三章 类、对象及方法

### 42. 工具类不可实例化
	
	1. 私有构造方法（反射还是能拿到）;
	2. 私有构造方法内抛异常;(解决反射问题)

### 47. 在 equals 中使用 getClass() 进行类型判断代替 instanceof

	instanceof 无法区分父类与子类;
	即再有继承或者实现的情况下，子类 instanceof 父类 为 true；

### 48. 覆写 equals() 则必须同时覆写 hashCode() ###

	Map 使用的是哈希表（数组+列表）存储结构，通过 key 的 hashCode 找到数组下标位置;
	推荐使用 HashCodeBuilder 工具类来实现；

### 49. 推荐覆写 toString() ###

	原始的 toString 方法打印内容没有实际意义;

### 50. 使用 package-info 为包服务 ###

	仅包内可访问到，功能如下：
	1. 定义公共类、常量;
	2. 给包标注注解;
	3. 提供包的整体注释说明;

### 51. 不要主动进行垃圾回收 ###

	主动调用：System.gc() 会暂停当前所有操作，直到 gc 完成；

## 第四章 字符串 

### 52. 推荐 String 直接赋值 ###

	eg： String str = "aa"; 不要 new String("aa")；

### 53. 注意方法参数要求 ###

### 54. 正确使用 String、StringBuffer、StringBuilder ###

### 55. 字符串用 "+" 拼接问题 ###

	"+" 遇到字符串时，所有类型都变成字符串，对象则调用 toString()；
	eg: 1 + 2 + "num" = "3num"
	eg: "num" + 1 + 2 = "num12"
	
### 56. 字符串拼接 ###

	性能排名:
	"+" < concat() < stringBuffer.append() 

### 57. 复杂字符串操作中使用正则表达式 ###

### 58. 强烈建议使用 UTF-8 编码 ###

### 59. 字符串对中文排序问题 ###

	默认是按中文的 unicode 编码排序；
	自定义排序规则：Collator.getInstance(Locale.CHINA)  推荐;

## 第五章 数组和集合 ##

### 60. 首选数组，而非集合 ###

	数组效率最高，集合底层实现也是数组;

### 61. 实现变长数组 ###

	数组一旦定义，其长度是固定的，开发中可自己实现可变长方法;
	eg: Arrays.copyOf()， 将原数组复制一份并创建新数组;

### 62. 警惕数组的浅拷贝 ###

	基本类型拷贝值，引用类型拷贝地址;
	Arrays.copyOf() 是浅拷贝，当数组存放的是对象是，需注意；

### 63. 为集合指定初始容量 ###

### 64. 最值算法选择 ###	

	推荐使用集合，降低代码复杂度，但效率低于自己实现遍历数组;
	TreeSet: 实现去重+排序；
	eg: ts.lower(ts.last())	: 查找第二名；

### 65. 数组转集合陷阱 ###

	Arrays.asList(array) ，此时的 array 如果是基础类型的数组，则会得到错误结果;
	因为基础类型不能泛型，想得到正确的结果，可改用其包装类型;

### 66. Arrays.asList() 生成的对象不可变更 ###

	长度固定，不能对其进行增、删，只能进行改、查;
	Arrays.asList() 生成的 ArrayList 非 java.util.ArrayList, 
	而是一个 Arrays 的内部内;

### 67. 列表遍历选择 ###

	随机存储列表 ArrayList，使用普通 for;
	（本身元素之间没有关联性，使用增强 for 时需要增加关联性）
	有序列表 LinkedList， 使用普通 for、 增强 for 差不多（等价于迭代器方式）;

### 68. 频繁插入和删除使用 LinkedList ###

	TODO 好像不对？？ ArrayList 性能并不差，对于大量数据时更好;

### 69. 列表相等判断时，只考虑元素内容是否相等 ###

	集合（List、Set、Map）只是个容器，所以比较集合里面的内容而不比较集合本身;
	
### 70. 子列表 subList() 只是原列表的一个视图 ###

	所有对子列表的操作，实际就是对原列表的操作;

### 71. 推荐使用 subList() 处理局部 ###

	eg: list.subList(1, 5).clear(); 删除下标为 1-4 的元素；

### 72. 调用 subList() 后，不要再操作原列表(增、删) ###

	子列表的所有操作都会判断原列表的大小是否修改;
	eg: Collections.unmodifiableList(list); 将列表设置为不可修改；







